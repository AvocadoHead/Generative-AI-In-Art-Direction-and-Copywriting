/* ========= TRANSLATIONS ========= */

const translations = {
  en: {
    brand: 'Crack the Brief | Multimodal Workshop',
    'hero.label': 'What Now',
    'hero.title': 'Everything happens at once.',
    'hero.subtitle':
      'Cracking the brief in the multimodal space. A deep-dive workshop in strategy, creative, and visual development in the age of Generative AI.',

    'shift.label': 'Paradigme',
    'shift.title': 'The shift: from “copy here, visual there” to one unified canvas.',
    'shift.body1':
      'Most of the industry still works in a “divide and fragment” mindset. Copy in one tab, images in another, and the original brief gets lost somewhere in the middle. The result: friction. Too many technical handoffs, not enough continuous creation.',
    'shift.body2':
      'This workshop moves you into a unified workflow. Forget ping-ponging between tools. We work on a single generative canvas, where written strategy and visual output evolve side by side.',

    'method.label': 'Recipe',
    'method.title': 'The methodology: from brief to video in 4 movements.',
    'method.intro':
      'A structured workflow that turns creative chaos into a precise pipeline.',
    'method.step1.label': 'Movement I',
    'method.step1.title': 'Decode the brief into story-DNA',
    'method.step1.body':
      'We begin by unpacking the brief into tone, tensions, emotional arc, and core images – before any prompt is written. The goal is to agree on what the piece really wants to say.',
    'method.step2.label': 'Movement II',
    'method.step2.title': 'Build the multimodal sketchbook',
    'method.step2.body':
      'From that story-DNA we generate visual and textual sketches: multiple prompt directions, camera and composition ideas, rhythm and typography. Everything lives on one canvas instead of scattered files.',
    'method.step3.label': 'Movement III',
    'method.step3.title': 'Refine into look & feel',
    'method.step3.body':
      'We sift through the experiments, keep what sings, and shape a clear look & feel: color, texture, motion language. The result is a visual direction everyone can recognize and work with.',
    'method.step4.label': 'Movement IV',
    'method.step4.title': 'Compose the final piece',
    'method.step4.body':
      'Finally we assemble the assets into a coherent flow: sequence of scenes, timing, typographic moments, sound and export strategy – from first frame to last.',

    'value.label': 'Outcome',
    'value.title': 'What you leave with',
    'value.intro':
      'The workshop is designed so you don’t just understand the method in theory – you walk out with something concrete.',
    'value.card1.title': 'A practical multimodal workflow',
    'value.card1.body':
      'A repeatable process you can reuse with different tools and briefs, without starting from zero every time a new platform appears.',
    'value.card2.title': 'A live project in progress',
    'value.card2.body':
      'A real piece – concept, board, or near-final video – built on top of your own material or an industry-style brief.',
    'value.card3.title': 'A shared language for the team',
    'value.card3.body':
      'A vocabulary that connects strategy, copy, design and motion, so the process becomes more fluid and less fragmented.',

    'bio.label': 'About me',
    'bio.title': 'Eyal Izenman',
    'bio.body':
      'Creator, animator, motion designer, and thought leader in the Generative AI space. With decades of weaving music, design and movement, Eyal Izenman works where human intuition meets algorithmic improvisation.',
    'bio.quote':
      '“AI is not a tech trick – it is a full creative space. My goal is to help you surface the idea, refine it, and turn it into a complete visual asset – in one continuous breath.”',

    'cta.line':
      'The full pipeline: Brief ← Story DNA ← Language & style ← Mutation ← Refinement ← Moodboard ← Look & Feel ← Storyboard ← Video.',
    'cta.button': 'Talk to me about the workshop'
  },
  he: {
    brand: 'לפצח את הבריף | סדנה לעבודה מולטימודלית',
    'hero.label': 'מה עכשיו',
    'hero.title': 'הכל קורה בבת אחת.',
    'hero.subtitle':
      'סדנה מעמיקה בפיצוח בריפים במרחב המולטימודלי – אסטרטגיה, קריאייטיב ופיתוח חזותי בעידן ה-AI הגנרטיבי.',

    'shift.label': 'פרדיגמה',
    'shift.title': 'המעבר: מטקסט פה וויז׳ואל שם – לקנבס אחד מאוחד.',
    'shift.body1':
      'רוב התעשייה עדיין עובדת בפיצול: טקסט בחלון אחד, תמונות באחר, והבריף המקורי הולך לאיבוד באמצע. התוצאה: חיכוך אינסופי, יותר מדי העברות, מעט מדי יצירה רציפה.',
    'shift.body2':
      'בסדנה אנחנו עוברים לקנבס גנרטיבי אחד, שבו שפה, רעיון ותמונה מתפתחים יחד – במקום להתרוצץ בין כלים וחלונות שונים.',

    'method.label': 'מתכון',
    'method.title': 'המתודולוגיה: מבריף לווידאו בארבעה מהלכים.',
    'method.intro':
      'תהליך מובנה שמארגן את הכאוס היצירתי לצינור עבודה ברור.',
    'method.step1.label': 'מהלך I',
    'method.step1.title': 'פירוק הבריף ל-DNA של סיפור',
    'method.step1.body':
      'מתחילים בתרגום הבריף לעמוד שדרה סיפורי: טון, מתחים, קשת רגשית ותמונות מרכזיות – עוד לפני שנכתבת מילה אחת של פרומפט.',
    'method.step2.label': 'מהלך II',
    'method.step2.title': 'מחברת הסקיצות המולטימודלית',
    'method.step2.body':
      'מה-DNA הסיפורי אנחנו מייצרים סקיצות – וריאציות של פרומפטים, בחירות מצלמה וקומפוזיציה, קצב וטיפוגרפיה – כולן חיות על אותו קנבס.',
    'method.step3.label': 'מהלך III',
    'method.step3.title': 'ממוּדבורד ללוק & פיל',
    'method.step3.body':
      'מצמצמים את הרעש לאסתטיקה ממוקדת: צבע, טקסטורות, חתימת תנועה. המטרה: לוק & פיל שכולם יכולים לזהות כ״זה שלנו״.',
    'method.step4.label': 'מהלך IV',
    'method.step4.title': 'הלחנת היצירה הסופית',
    'method.step4.body':
      'מסדרים הכול בזמן: סדר סצנות, קצב, רגעים טיפוגרפיים, סאונד ואסטרטגיית אקספורט – מפריים ראשון ועד אחרון.',

    'value.label': 'תוצאה',
    'value.title': 'עם מה אתם יוצאים מהסדנה',
    'value.intro':
      'המטרה היא שלא תצאו רק עם השראה – אלא עם מתודה ועם התחלה של יצירה משלכם.',
    'value.card1.title': 'מתודה מולטימודלית מעשית',
    'value.card1.body':
      'תהליך עבודה שניתן לשחזר על בריפים שונים וכלים משתנים, בלי להתחיל מאפס בכל פעם שיוצאת פלטפורמה חדשה.',
    'value.card2.title': 'פרויקט חי בתהליך',
    'value.card2.body':
      'קונספט, סקיצה או וידאו כמעט סופי – שנבנים על בסיס חומר שלכם או בריף משותף שעובדים עליו בסדנה.',
    'value.card3.title': 'שפה משותפת לצוות',
    'value.card3.body':
      'שפה שמחברת בין אסטרטגיה, קופי, עיצוב ותנועה – כך שהתהליך הופך זורם יותר ופחות מפוצל.',

    'bio.label': 'עליי',
    'bio.title': 'איל איזנמן',
    'bio.body':
      'יוצר, מנפיש ומעצב תנועה, מהקולות הבולטים בישראל בשדה ה-AI היצירתי. שוזר יחד מוזיקה, עיצוב ותנועה למרחבים גנרטיביים.',
    'bio.quote':
      '״AI הוא לא טריק טכנולוגי – הוא מרחב יצירתי שלם. המטרה שלי היא לעזור לך לזקק את הרעיון ולהפוך אותו לנכס חזותי שלם, בנשימה אחת רציפה.״',

    'cta.line':
      'הצינור המלא: בריף ← DNA של סיפור ← שפה וסגנון ← מוטציות ← ליטוש ← מוּדבורד ← לוק & פיל ← סטוריבורד ← וידאו.',
    'cta.button': 'דברו איתי על הסדנה'
  }
};

function applyTranslations(lang) {
  const dict = translations[lang] || translations.he;
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.getAttribute('data-i18n');
    if (dict[key]) el.textContent = dict[key];
  });
}

/* ========= WORD CLOUD ========= */

let canvas, ctx;
const words = [
  'ferment', 'distill', 'dream', 'style', 'composition', 'palette',
  'story', 'motive', 'theme', 'color', 'emotion', 'texture',
  'draft', 'mutation', 'refinement', 'prompt', 'camera', 'lens',
  'sound', 'motion', 'layout', 'cut', 'transition', 'timing',
  'vision', 'aesthetic', 'craft', 'form', 'content', 'meaning',
  'intention', 'expression', 'detail', 'gesture', 'spirit'
];

let particles = [];
let rotationX = 0;
let rotationY = 0;
let momentumX = 0;
let momentumY = 0;
let isDragging = false;
let lastMouseX = 0;
let lastMouseY = 0;

function initWordCloud() {
  canvas = document.getElementById('wordCloud');
  if (!canvas) return;
  ctx = canvas.getContext('2d');

  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // create particles on a sphere
  particles = [];
  const radius = 180;
  words.forEach(word => {
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(Math.random() * 2 - 1);
    particles.push({
      word,
      x: radius * Math.sin(phi) * Math.cos(theta),
      y: radius * Math.sin(phi) * Math.sin(theta),
      z: radius * Math.cos(phi)
    });
  });

  // mouse events
  canvas.addEventListener('mousedown', e => {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });

  canvas.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const deltaX = e.clientX - lastMouseX;
    const deltaY = e.clientY - lastMouseY;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    rotationY += deltaX * 0.005;
    rotationX += deltaY * 0.005;
    momentumY = deltaX * 0.0005;
    momentumX = deltaY * 0.0005;
  });

  canvas.addEventListener('mouseup', () => {
    isDragging = false;
    canvas.style.cursor = 'grab';
  });

  canvas.addEventListener('mouseleave', () => {
    isDragging = false;
    canvas.style.cursor = 'grab';
  });

  // touch events
  canvas.addEventListener('touchstart', e => {
    isDragging = true;
    const touch = e.touches[0];
    lastMouseX = touch.clientX;
    lastMouseY = touch.clientY;
  }, { passive: true });

  canvas.addEventListener('touchmove', e => {
    if (!isDragging) return;
    const touch = e.touches[0];
    const deltaX = touch.clientX - lastMouseX;
    const deltaY = touch.clientY - lastMouseY;
    lastMouseX = touch.clientX;
    lastMouseY = touch.clientY;
    rotationY += deltaX * 0.005;
    rotationX += deltaY * 0.005;
    momentumY = deltaX * 0.0005;
    momentumX = deltaY * 0.0005;
  }, { passive: true });

  canvas.addEventListener('touchend', () => {
    isDragging = false;
  }, { passive: true });

  canvas.style.cursor = 'grab';
  requestAnimationFrame(animateWordCloud);
}

function resizeCanvas() {
  if (!canvas || !ctx) return;
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function rotatePoint(x, y, z) {
  const cosY = Math.cos(rotationY);
  const sinY = Math.sin(rotationY);
  const tempX = x * cosY - z * sinY;
  const tempZ = z * cosY + x * sinY;

  const cosX = Math.cos(rotationX);
  const sinX = Math.sin(rotationX);
  const tempY = y * cosX - tempZ * sinX;
  const finalZ = tempZ * cosX + y * sinX;

  return { x: tempX, y: tempY, z: finalZ };
}

function animateWordCloud() {
  if (!canvas || !ctx) return;
  requestAnimationFrame(animateWordCloud);

  const rect = canvas.getBoundingClientRect();
  const width = rect.width;
  const height = rect.height;

  ctx.clearRect(0, 0, width, height);

  if (!isDragging) {
    rotationY += momentumY;
    rotationX += momentumX;
    momentumX *= 0.95;
    momentumY *= 0.95;
    rotationY += 0.001;   // slow auto-rotate
    rotationX += 0.0005;
  }

  const sorted = particles
    .map(p => {
      const rotated = rotatePoint(p.x, p.y, p.z);
      return { ...p, ...rotated };
    })
    .sort((a, b) => a.z - b.z);

  sorted.forEach(p => {
    const scale = 600 / (600 + p.z);
    const screenX = width / 2 + p.x * scale;
    const screenY = height / 2 + p.y * scale;
    const fontSize = 14 + scale * 8;
    const opacity = 0.3 + scale * 0.7;

    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.font = `${fontSize}px Heebo, sans-serif`;
    ctx.fillStyle = '#5a3418'; // warm brown text
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.word, screenX, screenY);
    ctx.restore();
  });
}

/* ========= SCROLL TRACE (random pastel multi-path) ========= */

let traceCanvas, traceCtx;
let tracePoints = [];
let traceNormalizedPoints = [];
let scrollTraceAnimating = false;

// Generate a random but smooth-ish polyline in normalized coordinates
function generateRandomNormalizedPath() {
  const segments = 7 + Math.floor(Math.random() * 4); // 7–10 points
  const points = [];

  for (let i = 0; i < segments; i++) {
    const t = i / (segments - 1); // 0 → 1

    // vertical progression, with slight jitter
    let y = t + (Math.random() - 0.5) * 0.08;
    y = Math.min(1, Math.max(0, y));

    // alternate left/right bias for a snaky feel
    const bias = i % 2 === 0 ? 0.75 : 0.25;
    let x = bias + (Math.random() - 0.5) * 0.25;
    x = Math.min(0.95, Math.max(0.05, x));

    points.push({ x, y });
  }

  return points;
}

function initScrollTrace() {
  traceCanvas = document.getElementById('scrollTrace');
  if (!traceCanvas) return;

  traceCtx = traceCanvas.getContext('2d');

  if (!traceNormalizedPoints.length) {
    traceNormalizedPoints = generateRandomNormalizedPath();
  }

  setupTraceSize();
  window.addEventListener('resize', setupTraceSize);
  window.addEventListener('scroll', onScrollTrace, { passive: true });

  drawScrollTrace(); // initial
}

function setupTraceSize() {
  if (!traceCanvas || !traceCtx) return;

  const dpr = window.devicePixelRatio || 1;
  const width = window.innerWidth;
  const height = window.innerHeight * 1.6; // a bit taller

  traceCanvas.width = width * dpr;
  traceCanvas.height = height * dpr;
  traceCanvas.style.width = '100%';
  traceCanvas.style.height = '100%';

  traceCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // map normalized points to pixel points
  tracePoints = traceNormalizedPoints.map(p => ({
    x: p.x * width,
    y: p.y * height
  }));
}

function onScrollTrace() {
  if (!scrollTraceAnimating) {
    scrollTraceAnimating = true;
    requestAnimationFrame(() => {
      drawScrollTrace();
      scrollTraceAnimating = false;
    });
  }
}

function drawScrollTrace() {
  if (!traceCanvas || !traceCtx || tracePoints.length < 2) return;

  const root = document.documentElement;
  const scrollTop = window.scrollY || root.scrollTop || 0;
  const maxScroll = (root.scrollHeight - window.innerHeight) || 1;
  const progress = Math.min(Math.max(scrollTop / maxScroll, 0), 1);

  const width = traceCanvas.width / (window.devicePixelRatio || 1);
  const height = traceCanvas.height / (window.devicePixelRatio || 1);

  traceCtx.clearRect(0, 0, width, height);

  // Describe a few flowing pastel paths
  // Create 3 flowing parallel paths with harmonious colors
  const paths = [
    { color: 'rgba(255, 200, 210, 0.6)', offset: -25, splits: [0.35, 0.75] },  // soft rose
    { color: 'rgba(200, 220, 255, 0.55)', offset: 0,   splits: [0.45, 0.82] },  // powder blue
    { color: 'rgba(240, 210, 255, 0.5)', offset: 25,  splits: [0.28, 0.68] }   // lavender
  ];
  const totalSegments = tracePoints.length - 1;
  const visibleProgress = Math.min(progress * 1.2, 1); // slightly ahead reveal
  const segPosition = visibleProgress * totalSegments;
  const fullSegments = Math.floor(segPosition);
  const partialT = segPosition - fullSegments;

  paths.forEach((pathConfig, pathIndex) => {
    traceCtx.save();
    traceCtx.strokeStyle = pathConfig.color;
    traceCtx.lineWidth = 2.5 + Math.sin(progress * Math.PI) * 0.5;
    traceCtx.shadowBlur = 15;
    traceCtx.shadowColor = pathConfig.color;
    traceCtx.filter = 'blur(0.5px)';

    const baseOffset = pathConfig.offset;

    traceCtx.beginPath();
    traceCtx.moveTo(tracePoints[0].x + baseOffset, tracePoints[0].y);

    for (let i = 0; i < totalSegments; i++) {
      if (i >= fullSegments + 1) break;

      const p0 = tracePoints[i];
      const p1 = tracePoints[i + 1];

      const dx = p1.x - p0.x;
      const dy = p1.y - p0.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const perpX = -dy / dist;
      const perpY = dx / dist;

      // Gentle organic wave - smoother and more fluid
      const waveOffset = 
        Math.sin((i / totalSegments) * Math.PI * 1.5 + pathIndex * 0.5) * dist * 0.12;
      const cp1x = p0.x + dx * 0.33 + perpX * waveOffset + baseOffset;
      const cp1y = p0.y + dy * 0.33 + perpY * waveOffset;
      const cp2x = p0.x + dx * 0.66 + perpX * waveOffset + baseOffset;
      const cp2y = p0.y + dy * 0.66 + perpY * waveOffset;

      if (i < fullSegments) {
        traceCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p1.x + baseOffset, p1.y);
      } else if (i === fullSegments) {
        const qx = p0.x + dx * partialT;
        const qy = p0.y + dy * partialT;
        const pcp1x = p0.x + (qx - p0.x) * 0.33 + perpX * waveOffset + baseOffset;
        const pcp1y = p0.y + (qy - p0.y) * 0.33 + perpY * waveOffset;
        const pcp2x = p0.x + (qx - p0.x) * 0.66 + perpX * waveOffset + baseOffset;
        const pcp2y = p0.y + (qy - p0.y) * 0.66 + perpY * waveOffset;
        traceCtx.bezierCurveTo(pcp1x, pcp1y, pcp2x, pcp2y, qx + baseOffset, qy);
        break;
      }
    }

    traceCtx.stroke();

    // SPLIT / MERGE effects
    pathConfig.splits.forEach(splitPoint => {
      if (progress > splitPoint) {
        const splitProgress = Math.min((progress - splitPoint) / 0.15, 1);
        const splitIdx = Math.floor(splitPoint * totalSegments);

        if (splitIdx < totalSegments - 2) {
          traceCtx.beginPath();
          traceCtx.globalAlpha = 0.6 * splitProgress;
          traceCtx.lineWidth = 2;

          const start = tracePoints[splitIdx];
          const branchOffset =
            (pathIndex % 2 === 0 ? 80 : -80) * splitProgress;

          traceCtx.moveTo(start.x + baseOffset, start.y);

          for (let j = 0; j < 4 && splitIdx + j < tracePoints.length; j++) {
            const t = j / 3;
            const p = tracePoints[splitIdx + j];
            const curveOffset = Math.sin(t * Math.PI) * branchOffset;
            traceCtx.lineTo(
              p.x + baseOffset + curveOffset,
              p.y
            );
          }

          traceCtx.stroke();
        }
      }
    });

    traceCtx.restore();
  });

  // glowing head dots
  const head = currentHeadPoint(progress);
  if (head && progress > 0.05) {
    paths.forEach(pathConfig => {
      traceCtx.beginPath();
      // bump alpha to ~0.9 for the dot
      const dotColor = pathConfig.color.replace('0.5)', '0.9)').replace('0.45)', '0.9)');
      traceCtx.fillStyle = dotColor;
      traceCtx.shadowBlur = 8;
      traceCtx.shadowColor = pathConfig.color;
      traceCtx.arc(head.x + pathConfig.offset, head.y, 3.5, 0, Math.PI * 2);
      traceCtx.fill();
    });
  }
}

function currentHeadPoint(progress) {
  const totalSegments = tracePoints.length - 1;
  const segPosition = progress * totalSegments;
  const segIndex = Math.floor(segPosition);
  const t = segPosition - segIndex;

  if (segIndex < 0 || segIndex >= totalSegments) return null;

  const p0 = tracePoints[segIndex];
  const p1 = tracePoints[segIndex + 1];

  return {
    x: p0.x + (p1.x - p0.x) * t,
    y: p0.y + (p1.y - p0.y) * t
  };
}

/* ========= DOM READY ========= */

document.addEventListener('DOMContentLoaded', () => {
  // start in Hebrew, RTL
  document.documentElement.lang = 'he';
  document.documentElement.dir = 'rtl';
  applyTranslations('he');

  // language toggle
  document.querySelectorAll('.lang-toggle button').forEach(btn => {
    btn.addEventListener('click', () => {
      document
        .querySelectorAll('.lang-toggle button')
        .forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      const lang = btn.dataset.lang;
      applyTranslations(lang);

      if (lang === 'he') {
        document.documentElement.lang = 'he';
        document.documentElement.dir = 'rtl';
      } else {
        document.documentElement.lang = 'en';
        document.documentElement.dir = 'ltr';
      }
    });
  });

  // scroll-in animations
  const observer = new IntersectionObserver(
    entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    },
    { threshold: 0.1 }
  );

  document.querySelectorAll('.anim').forEach(el => observer.observe(el));

  // init features
  initWordCloud();
  initScrollTrace();
});
